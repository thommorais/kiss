{"version":3,"sources":["scripts/helpers/smoothscroll.js"],"names":["defaultOptions","activeElement","observer","refreshSize","frameRate","animationTime","stepSize","pulseAlgorithm","pulseScale","pulseNormalize","accelerationDelta","accelerationMax","keyboardSupport","arrowScroll","fixedBackground","excluded","options","isExcluded","isFrame","direction","x","y","initDone","root","document","documentElement","deltaBuffer","isMac","test","navigator","platform","key","left","up","right","down","spacebar","pageup","pagedown","end","home","arrowKeys","init","body","html","windowHeight","window","innerHeight","scrollHeight","top","compatMode","indexOf","addEvent","keydown","self","isOldSafari","offsetHeight","fullPageElem","pendingRefresh","createElement","style","cssText","appendChild","setTimeout","height","MutationObserver","observe","attributes","childList","characterData","clearfix","clear","backgroundAttachment","que","pending","lastScroll","Date","now","scrollArray","elem","directionCheck","elapsed","factor","Math","min","push","lastX","lastY","start","scrollWindow","requestFrame","step","time","scrollX","scrollY","i","length","item","finished","position","pulse","splice","scrollBy","scrollLeft","scrollTop","wheel","event","target","defaultPrevented","ctrlKey","isNodeName","src","shadowRoot","deltaX","wheelDeltaX","deltaY","wheelDeltaY","isDivisible","abs","wheelDelta","deltaMode","overflowing","overflowingAncestor","isTouchpad","shift","clearTimeout","deltaBufferTimer","localStorage","SS_deltaBuffer","join","e","allDeltasDivisableBy","preventDefault","scheduleClearCache","isChrome","Object","defineProperty","value","frameElement","parent","modifier","altKey","metaKey","shiftKey","keyCode","contains","inputNodeNames","buttonTypes","nodeName","type","isContentEditable","clientHeight","scroll","scrollRemaining","scrollTo","mousedown","uniqueID","clearCacheTimer","el","cache","setInterval","setCache","elems","rootScrollHeight","cached","topOverflowsNotHidden","isOverflowCSS","overflowNotHidden","overflowAutoOrScroll","isContentOverflowing","getScrollRoot","parentElement","overflow","getComputedStyle","getPropertyValue","fn","addEventListener","passive","removeEvent","removeEventListener","tag","toLowerCase","split","n","divisor","floor","SCROLL_ROOT","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","element","delay","WebKitMutationObserver","MozMutationObserver","dummy","classList","add","bodyScrollTop","removeChild","pulse_","val","exp","userAgent","wheelEvent","isEdge","isSafari","isMobile","isIEWin7","isEnabledForBrowser","SmoothScroll","optionsToSet","hasOwnProperty","destroy","cleanup","disconnect","SmoothScrollOptions","define","amd","exports","module"],"mappings":"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","file":"smoothscroll.7278d923.js","sourceRoot":"..","sourcesContent":["(function () {\n\n// Scroll letiables (tweakable)\nlet defaultOptions = {\n\n    // Scrolling Core\n    frameRate        : 150, // [Hz]\n    animationTime    : 400, // [ms]\n    stepSize         : 100, // [px]\n\n    // Pulse (less tweakable)\n    // ratio of \"tail\" to \"acceleration\"\n    pulseAlgorithm   : true,\n    pulseScale       : 4,\n    pulseNormalize   : 1,\n\n    // Acceleration\n    accelerationDelta : 350,  // 50\n    accelerationMax   : 3,   // 3\n\n    // Keyboard Settings\n    keyboardSupport   : true,  // option\n    arrowScroll       : 50,    // [px]\n\n    // Other\n    fixedBackground   : true,\n    excluded          : ''\n};\n\nlet options = defaultOptions;\n\n\n// Other letiables\nlet isExcluded = false;\nlet isFrame = false;\nlet direction = { x: 0, y: 0 };\nlet initDone  = false;\nlet root = document.documentElement;\nlet activeElement;\nlet observer;\nlet refreshSize;\nlet deltaBuffer = [];\nlet isMac = /^Mac/.test(navigator.platform);\n\nlet key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32,\n            pageup: 33, pagedown: 34, end: 35, home: 36 };\nlet arrowKeys = { 37: 1, 38: 1, 39: 1, 40: 1 };\n\n/***********************************************\n * INITIALIZE\n ***********************************************/\n\n/**\n * Tests if smooth scrolling is allowed. Shuts down everything if not.\n */\nfunction initTest() {\n    if (options.keyboardSupport) {\n        addEvent('keydown', keydown);\n    }\n}\n\n/**\n * Sets up scrolls array, determines if frames are involved.\n */\nfunction init() {\n\n    if (initDone || !document.body) return;\n\n    initDone = true;\n\n    let body = document.body;\n    let html = document.documentElement;\n    let windowHeight = window.innerHeight;\n    let scrollHeight = body.scrollHeight;\n\n    // check compat mode for root element\n    root = (document.compatMode.indexOf('CSS') >= 0) ? html : body;\n    activeElement = body;\n\n    initTest();\n\n    // Checks if this script is running in a frame\n    if (top != self) {\n        isFrame = true;\n    }\n\n    /**\n     * Safari 10 fixed it, Chrome fixed it in v45:\n     * This fixes a bug where the areas left and right to\n     * the content does not trigger the onmousewheel event\n     * on some pages. e.g.: html, body { height: 100% }\n     */\n    else if (isOldSafari &&\n             scrollHeight > windowHeight &&\n            (body.offsetHeight <= windowHeight ||\n             html.offsetHeight <= windowHeight)) {\n\n        let fullPageElem = document.createElement('div');\n        fullPageElem.style.cssText = 'position:absolute; z-index:-10000; ' +\n                                     'top:0; left:0; right:0; height:' +\n                                      root.scrollHeight + 'px';\n        document.body.appendChild(fullPageElem);\n\n        // DOM changed (throttled) to fix height\n        let pendingRefresh;\n        refreshSize = function () {\n            if (pendingRefresh) return; // could also be: clearTimeout(pendingRefresh);\n            pendingRefresh = setTimeout(function () {\n                if (isExcluded) return; // could be running after cleanup\n                fullPageElem.style.height = '0';\n                fullPageElem.style.height = root.scrollHeight + 'px';\n                pendingRefresh = null;\n            }, 500); // act rarely to stay fast\n        };\n\n        setTimeout(refreshSize, 10);\n\n        addEvent('resize', refreshSize);\n\n        // TODO: attributeFilter?\n        let config = {\n            attributes: true,\n            childList: true,\n            characterData: false\n            // subtree: true\n        };\n\n        observer = new MutationObserver(refreshSize);\n        observer.observe(body, config);\n\n        if (root.offsetHeight <= windowHeight) {\n            let clearfix = document.createElement('div');\n            clearfix.style.clear = 'both';\n            body.appendChild(clearfix);\n        }\n    }\n\n    // disable fixed background\n    if (!options.fixedBackground && !isExcluded) {\n        body.style.backgroundAttachment = 'scroll';\n        html.style.backgroundAttachment = 'scroll';\n    }\n}\n\n/**\n * Removes event listeners and other traces left on the page.\n */\nfunction cleanup() {\n    observer && observer.disconnect();\n    removeEvent(wheelEvent, wheel);\n    removeEvent('mousedown', mousedown);\n    removeEvent('keydown', keydown);\n    removeEvent('resize', refreshSize);\n    removeEvent('load', init);\n}\n\n\n/************************************************\n * SCROLLING\n ************************************************/\n\nlet que = [];\nlet pending = false;\nlet lastScroll = Date.now();\n\n/**\n * Pushes scroll actions to the scrolling queue.\n */\nfunction scrollArray(elem, left, top) {\n\n    directionCheck(left, top);\n\n    if (options.accelerationMax != 1) {\n        let now = Date.now();\n        let elapsed = now - lastScroll;\n        if (elapsed < options.accelerationDelta) {\n            let factor = (1 + (50 / elapsed)) / 2;\n            if (factor > 1) {\n                factor = Math.min(factor, options.accelerationMax);\n                left *= factor;\n                top  *= factor;\n            }\n        }\n        lastScroll = Date.now();\n    }\n\n    // push a scroll command\n    que.push({\n        x: left,\n        y: top,\n        lastX: (left < 0) ? 0.99 : -0.99,\n        lastY: (top  < 0) ? 0.99 : -0.99,\n        start: Date.now()\n    });\n\n    // don't act if there's a pending queue\n    if (pending) {\n        return;\n    }\n\n    let scrollWindow = (elem === document.body);\n\n    let step = function (time) {\n\n        let now = Date.now();\n        let scrollX = 0;\n        let scrollY = 0;\n\n        for (let i = 0; i < que.length; i++) {\n\n            let item = que[i];\n            let elapsed  = now - item.start;\n            let finished = (elapsed >= options.animationTime);\n\n            // scroll position: [0, 1]\n            let position = (finished) ? 1 : elapsed / options.animationTime;\n\n            // easing [optional]\n            if (options.pulseAlgorithm) {\n                position = pulse(position);\n            }\n\n            // only need the difference\n            let x = (item.x * position - item.lastX) >> 0;\n            let y = (item.y * position - item.lastY) >> 0;\n\n            // add this to the total scrolling\n            scrollX += x;\n            scrollY += y;\n\n            // update last values\n            item.lastX += x;\n            item.lastY += y;\n\n            // delete and step back if it's over\n            if (finished) {\n                que.splice(i, 1); i--;\n            }\n        }\n\n        // scroll left and top\n        if (scrollWindow) {\n            window.scrollBy(scrollX, scrollY);\n        }\n        else {\n            if (scrollX) elem.scrollLeft += scrollX;\n            if (scrollY) elem.scrollTop  += scrollY;\n        }\n\n        // clean up if there's nothing left to do\n        if (!left && !top) {\n            que = [];\n        }\n\n        if (que.length) {\n            requestFrame(step, elem, (1000 / options.frameRate + 1));\n        } else {\n            pending = false;\n        }\n    };\n\n    // start a new queue of actions\n    requestFrame(step, elem, 0);\n    pending = true;\n}\n\n\n/***********************************************\n * EVENTS\n ***********************************************/\n\n/**\n * Mouse wheel handler.\n * @param {Object} event\n */\nfunction wheel(event) {\n\n    if (!initDone) {\n        init();\n    }\n\n    let target = event.target;\n\n    // leave early if default action is prevented\n    // or it's a zooming event with CTRL\n    if (event.defaultPrevented || event.ctrlKey) {\n        return true;\n    }\n\n    // leave embedded content alone (flash & pdf)\n    if (isNodeName(activeElement, 'embed') ||\n       (isNodeName(target, 'embed') && /\\.pdf/i.test(target.src)) ||\n        isNodeName(activeElement, 'object') ||\n        target.shadowRoot) {\n        return true;\n    }\n\n    let deltaX = -event.wheelDeltaX || event.deltaX || 0;\n    let deltaY = -event.wheelDeltaY || event.deltaY || 0;\n\n    if (isMac) {\n        if (event.wheelDeltaX && isDivisible(event.wheelDeltaX, 120)) {\n            deltaX = -120 * (event.wheelDeltaX / Math.abs(event.wheelDeltaX));\n        }\n        if (event.wheelDeltaY && isDivisible(event.wheelDeltaY, 120)) {\n            deltaY = -120 * (event.wheelDeltaY / Math.abs(event.wheelDeltaY));\n        }\n    }\n\n    // use wheelDelta if deltaX/Y is not available\n    if (!deltaX && !deltaY) {\n        deltaY = -event.wheelDelta || 0;\n    }\n\n    // line based scrolling (Firefox mostly)\n    if (event.deltaMode === 1) {\n        deltaX *= 40;\n        deltaY *= 40;\n    }\n\n    let overflowing = overflowingAncestor(target);\n\n    // nothing to do if there's no element that's scrollable\n    if (!overflowing) {\n        // except Chrome iframes seem to eat wheel events, which we need to\n        // propagate up, if the iframe has nothing overflowing to scroll\n        if (isFrame && isChrome)  {\n            // change target to iframe element itself for the parent frame\n            Object.defineProperty(event, \"target\", {value: window.frameElement});\n            return parent.wheel(event);\n        }\n        return true;\n    }\n\n    // check if it's a touchpad scroll that should be ignored\n    if (isTouchpad(deltaY)) {\n        return true;\n    }\n\n    // scale by step size\n    // delta is 120 most of the time\n    // synaptics seems to send 1 sometimes\n    if (Math.abs(deltaX) > 1.2) {\n        deltaX *= options.stepSize / 120;\n    }\n    if (Math.abs(deltaY) > 1.2) {\n        deltaY *= options.stepSize / 120;\n    }\n\n    scrollArray(overflowing, deltaX, deltaY);\n    event.preventDefault();\n    scheduleClearCache();\n}\n\n/**\n * Keydown event handler.\n * @param {Object} event\n */\nfunction keydown(event) {\n    let target   = event.target;\n    let modifier = event.ctrlKey || event.altKey || event.metaKey ||\n                  (event.shiftKey && event.keyCode !== key.spacebar);\n\n\n    if(event.keyCode === key.spacebar){\n         window.scrollTo(window.innerHeight, 0)\n        return\n    }\n\n    // our own tracked active element could've been removed from the DOM\n    if (!document.body.contains(activeElement)) {\n        activeElement = document.activeElement;\n    }\n\n    // do nothing if user is editing text\n    // or using a modifier key (except shift)\n    // or in a dropdown\n    // or inside interactive elements\n    let inputNodeNames = /^(textarea|select|embed|object)$/i;\n    let buttonTypes = /^(button|submit|radio|checkbox|file|color|image)$/i;\n    if ( event.defaultPrevented ||\n         inputNodeNames.test(target.nodeName) ||\n         isNodeName(target, 'input') && !buttonTypes.test(target.type) ||\n         isNodeName(activeElement, 'video') ||\n         target.isContentEditable ||\n         modifier ) {\n      return true;\n    }\n\n    // [spacebar] should trigger button press, leave it alone\n    if ((isNodeName(target, 'button') ||\n         isNodeName(target, 'input') && buttonTypes.test(target.type)) &&\n        event.keyCode === key.spacebar) {\n      return true;\n    }\n\n    // [arrwow keys] on radio buttons should be left alone\n    if (isNodeName(target, 'input') && target.type == 'radio' &&\n        arrowKeys[event.keyCode])  {\n      return true;\n    }\n\n    let shift, x = 0, y = 0;\n    let overflowing = overflowingAncestor(activeElement);\n\n    if (!overflowing) {\n        // Chrome iframes seem to eat key events, which we need to\n        // propagate up, if the iframe has nothing overflowing to scroll\n        return (isFrame && isChrome) ? parent.keydown(event) : true;\n    }\n\n    let clientHeight = overflowing.clientHeight;\n\n    if (overflowing == document.body) {\n        clientHeight = window.innerHeight;\n    }\n\n    switch (event.keyCode) {\n        case key.up:\n            y = -options.arrowScroll;\n            break;\n        case key.down:\n            y = options.arrowScroll;\n            break;\n        case key.spacebar: // (+ shift)\n            shift = event.shiftKey ? 1 : -1;\n            y = -shift * clientHeight * 0.9;\n            break;\n        case key.pageup:\n            y = -clientHeight * 0.9;\n            break;\n        case key.pagedown:\n            y = clientHeight * 0.9;\n            break;\n        case key.home:\n            y = -overflowing.scrollTop;\n            break;\n        case key.end:\n            let scroll = overflowing.scrollHeight - overflowing.scrollTop;\n            let scrollRemaining = scroll - clientHeight;\n            y = (scrollRemaining > 0) ? scrollRemaining + 10 : 0;\n            break;\n        case key.left:\n            x = -options.arrowScroll;\n            break;\n        case key.right:\n            x = options.arrowScroll;\n            break;\n        default:\n            return true; // a key we don't care about\n    }\n\n    scrollArray(overflowing, x, y);\n    event.preventDefault();\n    scheduleClearCache();\n}\n\n/**\n * Mousedown event only for updating activeElement\n */\nfunction mousedown(event) {\n    activeElement = event.target;\n}\n\n\n/***********************************************\n * OVERFLOW\n ***********************************************/\n\nlet uniqueID = (function () {\n    let i = 0;\n    return function (el) {\n        return el.uniqueID || (el.uniqueID = i++);\n    };\n})();\n\nvar cache = {}; // cleared out after a scrolling session\nvar clearCacheTimer;\n\n//setInterval(function () { cache = {}; }, 10 * 1000);\n\nfunction scheduleClearCache() {\n    clearTimeout(clearCacheTimer);\n    clearCacheTimer = setInterval(function () { cache = {}; }, 1*1000);\n}\n\nfunction setCache(elems, overflowing) {\n    for (var i = elems.length; i--;)\n        cache[uniqueID(elems[i])] = overflowing;\n    return overflowing;\n}\n\n//  (body)                (root)\n//         | hidden | visible | scroll |  auto  |\n// hidden  |   no   |    no   |   YES  |   YES  |\n// visible |   no   |   YES   |   YES  |   YES  |\n// scroll  |   no   |   YES   |   YES  |   YES  |\n// auto    |   no   |   YES   |   YES  |   YES  |\n\nfunction overflowingAncestor(el) {\n    let elems = [];\n    let body = document.body;\n    let rootScrollHeight = root.scrollHeight;\n    do {\n        let cached = cache[uniqueID(el)];\n        if (cached) {\n            return setCache(elems, cached);\n        }\n        elems.push(el);\n        if (rootScrollHeight === el.scrollHeight) {\n            let topOverflowsNotHidden = overflowNotHidden(root) && overflowNotHidden(body);\n            let isOverflowCSS = topOverflowsNotHidden || overflowAutoOrScroll(root);\n            if (isFrame && isContentOverflowing(root) ||\n               !isFrame && isOverflowCSS) {\n                return setCache(elems, getScrollRoot());\n            }\n        } else if (isContentOverflowing(el) && overflowAutoOrScroll(el)) {\n            return setCache(elems, el);\n        }\n    } while (el = el.parentElement);\n}\n\nfunction isContentOverflowing(el) {\n    return (el.clientHeight + 10 < el.scrollHeight);\n}\n\n// typically for <body> and <html>\nfunction overflowNotHidden(el) {\n    let overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');\n    return (overflow !== 'hidden');\n}\n\n// for all other elements\nfunction overflowAutoOrScroll(el) {\n    let overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');\n    return (overflow === 'scroll' || overflow === 'auto');\n}\n\n\n/***********************************************\n * HELPERS\n ***********************************************/\n\nfunction addEvent(type, fn) {\n    window.addEventListener(type, fn, {passive: false});\n}\n\nfunction removeEvent(type, fn) {\n    window.removeEventListener(type, fn, {passive: false});\n}\n\nfunction isNodeName(el, tag) {\n    return (el.nodeName||'').toLowerCase() === tag.toLowerCase();\n}\n\nfunction directionCheck(x, y) {\n    x = (x > 0) ? 1 : -1;\n    y = (y > 0) ? 1 : -1;\n    if (direction.x !== x || direction.y !== y) {\n        direction.x = x;\n        direction.y = y;\n        que = [];\n        lastScroll = 0;\n    }\n}\n\nlet deltaBufferTimer;\n\nif (window.localStorage && localStorage.SS_deltaBuffer) {\n    try { // #46 Safari throws in private browsing for localStorage\n        deltaBuffer = localStorage.SS_deltaBuffer.split(',');\n    } catch (e) { }\n}\n\nfunction isTouchpad(deltaY) {\n    if (!deltaY) return;\n    if (!deltaBuffer.length) {\n        deltaBuffer = [deltaY, deltaY, deltaY];\n    }\n    deltaY = Math.abs(deltaY);\n    deltaBuffer.push(deltaY);\n    deltaBuffer.shift();\n    clearTimeout(deltaBufferTimer);\n    deltaBufferTimer = setTimeout(function () {\n        try { // #46 Safari throws in private browsing for localStorage\n            localStorage.SS_deltaBuffer = deltaBuffer.join(',');\n        } catch (e) { }\n    }, 1000);\n    return !allDeltasDivisableBy(120) && !allDeltasDivisableBy(100);\n}\n\nfunction isDivisible(n, divisor) {\n    return (Math.floor(n / divisor) == n / divisor);\n}\n\nfunction allDeltasDivisableBy(divisor) {\n    return (isDivisible(deltaBuffer[0], divisor) &&\n            isDivisible(deltaBuffer[1], divisor) &&\n            isDivisible(deltaBuffer[2], divisor));\n}\n\nlet requestFrame = (function () {\n      return (window.requestAnimationFrame       ||\n              window.webkitRequestAnimationFrame ||\n              window.mozRequestAnimationFrame    ||\n              function (callback, element, delay) {\n                 window.setTimeout(callback, delay || (1000/60));\n             });\n})();\n\nlet MutationObserver = (window.MutationObserver ||\n                        window.WebKitMutationObserver ||\n                        window.MozMutationObserver);\n\nlet getScrollRoot = (function() {\n  let SCROLL_ROOT = false\n  return function() {\n    if (!SCROLL_ROOT) {\n      let dummy = document.createElement('div');\n      dummy.classList.add('dummy')\n      dummy.style.cssText = 'height:10000px;width:1px;';\n      document.body.appendChild(dummy);\n      let bodyScrollTop  = document.body.scrollTop;\n      let docElScrollTop = document.documentElement.scrollTop;\n      window.scrollBy(0, 3);\n      if (document.body.scrollTop != bodyScrollTop)\n        (SCROLL_ROOT = document.body);\n      else\n        (SCROLL_ROOT = document.documentElement);\n      window.scrollBy(0, -3);\n      document.body.removeChild(dummy);\n    }\n    return SCROLL_ROOT;\n  };\n})();\n\n\n/***********************************************\n * PULSE (by Michael Herf)\n ***********************************************/\n\n/**\n * Viscous fluid with a pulse for part and decay for the rest.\n * - Applies a fixed force over an interval (a damped acceleration), and\n * - Lets the exponential bleed away the velocity over a longer interval\n * - Michael Herf, http://stereopsis.com/stopping/\n */\nfunction pulse_(x) {\n    let val, start, expx;\n    // test\n    x = x * options.pulseScale;\n    if (x < 1) { // acceleartion\n        val = x - (1 - Math.exp(-x));\n    } else {     // tail\n        // the previous animation ended here:\n        start = Math.exp(-1);\n        // simple viscous drag\n        x -= 1;\n        expx = 1 - Math.exp(-x);\n        val = start + (expx * (1 - start));\n    }\n    return val * options.pulseNormalize;\n}\n\nfunction pulse(x) {\n    if (x >= 1) return 1;\n    if (x <= 0) return 0;\n\n    if (options.pulseNormalize == 1) {\n        options.pulseNormalize /= pulse_(1);\n    }\n\n    return pulse_(x);\n}\n\n\n/***********************************************\n * FIRST RUN\n ***********************************************/\n\nlet userAgent = window.navigator.userAgent;\nlet isEdge    = /Edge/.test(userAgent); // thank you MS\nlet isChrome  = /chrome/i.test(userAgent) && !isEdge;\nlet isSafari  = /safari/i.test(userAgent) && !isEdge;\nlet isMobile  = /mobile/i.test(userAgent);\nlet isIEWin7  = /Windows NT 6.1/i.test(userAgent) && /rv:11/i.test(userAgent);\nlet isOldSafari = isSafari && (/Version\\/8/i.test(userAgent) || /Version\\/9/i.test(userAgent));\nlet isEnabledForBrowser = (isChrome || isSafari || isIEWin7) && !isMobile;\n\nlet wheelEvent;\nif ('onwheel' in document.createElement('div'))\n    wheelEvent = 'wheel';\nelse if ('onmousewheel' in document.createElement('div'))\n    wheelEvent = 'mousewheel';\n\nif (wheelEvent && isEnabledForBrowser) {\n    addEvent(wheelEvent, wheel);\n    addEvent('mousedown', mousedown);\n    addEvent('load', init);\n}\n\n/***********************************************\n * PUBLIC INTERFACE\n ***********************************************/\n\nfunction SmoothScroll(optionsToSet) {\n    for (let key in optionsToSet)\n        if (defaultOptions.hasOwnProperty(key))\n            options[key] = optionsToSet[key];\n}\n\nSmoothScroll.destroy = cleanup;\n\nif (window.SmoothScrollOptions) // async API\n    SmoothScroll(window.SmoothScrollOptions);\n\nif (typeof define === 'function' && define.amd)\n    define(function() {\n        return SmoothScroll;\n    });\nelse if ('object' == typeof exports)\n    module.exports = SmoothScroll;\nelse\n    window.SmoothScroll = SmoothScroll;\n\n})();"]}